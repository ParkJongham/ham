
# 스택 (stack)

[스택 코드 구현](https://github.com/ParkJongham/ham/blob/master/Coding/code/%EC%8A%A4%ED%83%9D.ipynb)

> 데이터를 임시 저장하는 기본 자료구조 중 하나로 데이터의 입력과 출력 순서는 후입선출 (LIFO) 방식.

푸시 (push) : 스택에 데이터를 넣는 작업.
팝 (pop) : 스택에서 데이터를 꺼내는 작업.
탑 (top) : 스택에 저장한 데이터의 맨 위. (가장 마지막에 저장한 데이터)
바닥 (bottom) : 스택에서 저장한 데이터의 맨 아래. (가장 먼저 저장한 데이터)

# 스택 알고리즘의 구성 요소

 __01. 스택의 배열 : stk__
> list 형 배열의 스택 본체. 인덱스가 0인 원소를 바닥이라고 한다. 즉, 가장 먼저 푸시된 데이터가 0번 인덱스를 가진다.

__02. 스택의 크기 : capacity__
> int 형 정수값으로 이루어진 스택의 최대 크기를 나타낸다. 즉, 스택의 배열 : stk 의 길이(len) 과 동일한 값을 가진다.

__03. 스택 포인터 : ptr  (stack pointer)__
> 정수값으로 이루어진 스택 데이터의 개수를 나타내는 것으로 , 스택이 비어있다면 포인터의 값은 0, 가득 차 있다면 포인터의 값은 capacity( 혹은 len(stk)) 와 같아진다.

* 스택 포인터의 범위 지정지 주의 사항
	-	FixedStack  클래스를 사용하여 스택 작업을 수행하는 경우 포인터의  ptr 값은 반드시 __0 이상이거나 capacity 값 이하__ 가 된다. 따라서 스택이 비어있는 경우 (is_empty()) 와 가득 차 있는 경우 (is_full()) 는 `==` 연산을 사용하여 정의할 수도 있다.
하지만 프로그램 오류 등으로 ptr 값이  0 보다 작아지거나  capacity가 커질 가능성도 있어 추천되는 방법은 아니다. `<=`, `>=` 의 부등호로 구성할 경우 스택 배열의 최소값 및 최대값에서 벗어난 접근을 방지할 수 있다.

__04. 예외 처리 클래스 Empty__ 
> pop(), peek() 함수를 호출 할 때 스택이 비어있으면 내보내는 예외처리.

__05. 예외 처리 클래스 Full__
> push() 함수를 호출할 때 스택이 가득 차 있으면 내보내는 예외처리.
	> - 스택이 가득 차 있으면 더 이상 넣지 못한다.

__06. 초기화하는 __init__() 함수
> __init__() 함수는 스택 배열을 생성하는 준비 작업을 수행. 매개변수로 capacity 로 전달받은 값을 받으며, 원소의 개수가 capacity 이고 각 원소가 None 인 리스트형 stk 를 생성. 비어있는 스택이므로, ptr 은 0 으로 설정한다.

__07. 쌓여있는 데이터 개수를 알아내는 __len__() 함수
> 스택 배열에 쌓여있는 데이터의 개수를 반환. (스택 포인터 ptr 값을 반환)

__08. 스택이 비어있는지를 판단하는 is_empty() 함수__
> 스택이 비어 있다면 True, 아닐 경우  False 인 bool 값을 반환.

__09. 스택이 가득 차 있는지를 판단하는 is_full() 함수__
> 더 이상 스택에 데이터를 푸시할 수 없는 상태를 판단하는 함수로, 스택이 가득 차 있으면 True, 아닐 경우 False 인 bool 값을 반환.

* 예외처리 기본구조 
> try 문을 통해 예외처리를 수행할 수 있으며,
> ||||
>---| ---|---|
> __try 문__|__try-finally 문__|
> try문 : 원래 처리|try : 스위트 (1개 이상)|try : 스위트
> except문 : 예외 포착과 처리|except 예외 : 스위트 작성 (생략 가능)|finally : 스위트
> else문 : 예외가 포착되지 않음|else : 스위트 (생략 가능)|
> finally문 : 마무리|finally : 스위트|

__10. 데이터를 푸시하는 push() 함수__
> 생성된 스택 배열에 데이터를 추가하는 함수.

__11. 데이터를 팝하는 pop() 함수__
> 스택 배열에서 저장되어 있는 데이터를 꺼내는 함수. 탑부터 꺼내게되며, (stk[ptr-1] 을 반환) 스택이 비어있는 경우 FixedStack Empty 를 통해 예외처리를 한다.

__12. 데이터를 들여다보는 peek() 함수__
> 스택의 탑에서부터(다음에 팝하는 데이터) 를 들여다 보는 함수. 스택이 비어있는 경우 FixedStack Empty 를 통해 예외처리를 하며, 비어있지 않다면 stk[ptr-1] 값을 반환한다.

__13. 스택의 모든 데이터를 삭제하는 clear() 함수__
> 스택에 저장된 모든 데이터를 삭제하여 빈 스택으로 만드는 함수. 간단하게 스택 포인터 ptr 의 값을 0으로 만들어주는 것으로 생성이 가능하다.

* raise 문을 통한 예외처리
	- try문 외에 raise 문을 통한 예외처리도 가능하며, `raise 스위트` 로 사용이 가능하다.

__14. 데이터를 검색하는 find() 함수__
> 스택 본체의 배열 stk 안에 value 와 값이 같은 데이터가 포함되어 있는지 확인하는 함수로, 포함되어 있다면 배열의 어디에 들어있는지 검색한다.
> __탑에서부터 바닥으로 선형 검색을 수행__ 하며, 검색에 성공하면 발견한 원소의 인덱스 값을 반환하고, 실패하면 -1을 반환한다.

__15. 데이터 개수를 세는 count() 함수__
> 스택에 쌓여있는 데이터 (value) 의 개수를 반환한다.

__16. 데이터가 포함되어 있는지 판단하는 __contains__() 함수__
> 스택에 데이터 (value) 가 있는지를 판단. 포함되어 있다면 True 를 반환, 포함되어 있지 않을 경우 False 를 반환한다.
>	 - 스택 s 에 데이터 x 가 포함되어 있는지 판단하고자 한다면 `s.__contains__(x)`  뿐만아니라 멤버십 판단 연산자 (membership test operator) 인 `in` 을 사용하여 `x in s` 수행 가능하다.

__17. 스택의 모든 데이터를 출력하는 dump() 함수__
> 스택에 쌓여있는 ptr 개의 모든 데이터를 바닥부터 탑까지 순서대로 출력한다. (처음 입력한 순서대로 출력)
> 스택이 비어있다면  "스택이 비어 있습니다." 를 출력.

* __`__len__()` 함수와 `__contains__()` 함수__
	* `__len__()` 함수 : 클래스에 `__len__()` 함수를 정의하면 클래스형의 인스턴스 `__len__()` 함수에 전달 할 수 있다.
	* 예) 클래스형 인스턴스 obj 에 대한 `__len__()` 함수를 호출하는 `obj.__len__()` 를 `len(obj)` 로 작성 가능.

	* `__contains__()` 함수 : 클래스에 `__contains__()` 함수를 정의하면 클래스형 인스턴스 멤버십 판단 연산자인 `in`  을 적용할 수 있다.
	* 예) 클래스형 obj에 대한 `__contains__()` 함수를 호출하는 obj.__contains__(x) 를 `x in obj` 로 작성 가능.


* collections.deeque 로 스택 구현

[deque를 통한 스택 코드 구현](https://github.com/ParkJongham/ham/blob/master/Coding/code/deque(%EC%8A%A4%ED%83%9D).ipynb)

> 파이썬의 내장 컨테이너 중 하나인 `deque` 모듈을 통해 스택을 구현할 수 있다.
> > __덱 (deque)__ :  자료의 맨 앞과 끝, 양쪽에서 원소를 추가 / 삭제하는 자료구조. 양 방향에서 원소를 추가 / 삭제하므로 2개의 포인터를 사용한다. 큐와 스택을 합친 형태.
>>||||
>>---|---|---|
>>속성과 함수|설명|
>>maxlen 속성| deque 의 최대 크기를 나타내는 속성으로 읽기 전용. 크기 제한이 없으면 None 이다.
>>append(x) 함수|deque 맨 끝 (오른쪽) 에 x 를 추가.
>>appendleft(x) 함수|deque 맨 앞 (왼쪽)에 x를 추가.
>>clear() 함수|deque의 모든 원소를 삭제하고 크기를 0으로 한다.
>>copy() 함수|deque의 얕은 복사 (shallow copy) 를 한다.
>>count(x) 함수|deque 안에 있는 x와 같은 원소의 개수를 계산한다.
>>extend(iterable) 함수|순차 반복 인수 iterable에서 가져온 원소를 deque의 맨 앞 (오른쪽) 에 추가하여 확장한다.
>> extendleft(iterable)|순차 반복 인수 iterable에서 가져온 우너소를 deque 맨 앞 (왼쪽) 에 추가하여 확장한다.
>>index(x[, start [, stop]]) 함수|deque 안에 있는 (인덱스 start 부터 인덱스 stop 까지 양 끝을 포함한 범위) x 가운데 가장 앞쪽에 있는 원소의 위치를 반환한다. x 가 없는 경우 value error 가 난다.
>>insert(i, x) 함수|x 를 deque의 i 위치에 삽입한다. 이때 크기에 제한이 있는 deque 일 경우 maxlen 을 초과한 삽입은 Index errorr 가 난다.
>>pop() 함수|deque의 맨 끝 (오른쪽) 에 있는 원소를 1개 삭제하고 그 원소를 반환한다. 원소가 하나도 없는 경우 index error 가 난다.
>>popleft() 함수|deque 의 맨 앞 (왼쪽) 에 있는 원소를 1개 삭제하고 그 원소를 반환한다. 원소가 하나도 없는 경우 index error	가 난다.
>>remove(value) 함수|value 의 첫번째 항목을 삭제한다. 원소가 없는 경우 value error 가 난다.
>>reverse() 함수|deque 원소를 역순으로 재정렬하고 None 를 반환한다.
>>rotate(n=1) 함수|deque 의 모든 원소를 n 값 만큼 오른쪽으로 밀어낸다. n 이 음수라면 왼쪽으로 밀어낸다.
>> * 양쪽 끝 데이터를 인덱스로 접근하는 것은 빠르나, 가운데 부분의 데이터로 접근하는 것은 느리다. 따라서 인덱스를 사용하여 임의의 원소를 무작위로 접근하는 것은 비효율적이다.

# 큐 (queue)

[큐 코드 구현](https://github.com/ParkJongham/ham/blob/master/Coding/code/%ED%81%90.ipynb)

> 데이터를 임시 저장하는 자료구조로, 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 (FIFO) 구조로 이루어져있다. 

인큐 (enqueue) : 자료구조 큐에 데이터를 추가하는 작업.
디큐 (dequeue) : 자료구조 큐에 데이터를 꺼내는 작업.
프런트 (front) : 데이터를 꺼내는 쪽을 지칭.
리어 (rear) : 데이터를 넣는 쪽을 지칭.

* 우선순위 큐 (priority queue) : 인큐 시 데이터에 우선 순위를 부여하여, 디큐 시 우선순위가 높은 데이터를 꺼내는 방식. 
heapq 모듈에서 제공하는 기능으로, 인큐는 `heapq.heappush(head, data)` 로 수행하며, 디큐는 `heapq.heappop(heap)` 로 수행한다.

# 큐 알고리즘의 구성 요소

__01. 예외 처리 클래스 Empty 와 Full__
> - Empty 클래스 : 비어 있는 큐에 `deque()`, `peek()`  함수를 호출할 때 내보내는 예외처리.
>  - Full 클래스 : 가득 차 있는 큐에 `enque()` 함수를 호출할 떄 내보내는 예외처리는 

__02. 초기화하는 `__init__()` 함수__
> 큐 배열을 생성하는 준비 작업을 수행하며, 5개의 변수 값을 설정
	> - que : 큐의 배열로서 밀어 넣는 데이터를 저장하는 list 형 배열.
	> - capacity : 큐의 최대 크기를 나타내는 int형 정수. 배열 que 의 원소  수와 일치.
	> - front, rear : 맨 앞의 원소의 인덱스, 맨 뒤의 원소의 다음 인덱스.
	> - no : 큐에 쌓여 있는 데이터의 개수를 나타내는 int형 정수. 프런트와 리어의 값이 일치하는 경우 큐가 가득찬 상황인지, 비어 있는지를 판별한다. 큐가 비어있는 경우 0이 되고, 가득 차있는 경우 capacity 와 같은 값이 된다.

__03. 추가한 데이터 개수를 알아내는 `__len__()` 함수__
> 큐에 추가한 데이터 개수를 반환. no 값은 그대로 반환.

__04. 큐가 비어있는지를 판단하는 `is_empty()` 함수__
> 큐가 비어있는지를 판단. 비어있다면 True, 비어있지 않다면 False 를 반환.

__05. 큐가 가득 차 있는지를 판단하는 `is_full()` 함수__
> 큐가 가득 차 있어 더이상 데이터를 추가할 수 없는 상태인지를 판별. 가득차 있다면 True, 아니면 False 를 반환.

__06. 데이터를 넣는 `enque()` 함수__
> 큐에 데이터를 넣는 함수. 하지만 큐가 가득 차 있을 경우 FixedQueue.Full 로 예외처리.

__07. 데이터를 꺼내는 `deque()` 함수__
> 큐의 맨 앞에서부터 데이터를 디큐하여 그 값을 반환. 큐가 비어있을 경우 FixedQueue.Empty 로 예외처리.

__08. 데이터를 들여다보는 `peek()` 함수__
> 맨 앞 데이터, 즉 다음 디큐에서  꺼낼 데이터를 들여다 보는 함수. que[front] 의 값을 반환하지만 꺼내지는 않는다. 큐가 비어있을 경우 FixedQueue.Empty 로 예외처리.

__09. 검색하는 `find()` 함수__
> 큐 배열에서 value 와 같은 데이터가 포함되어 있는 위치를 찾는 함수. 큐의 맨 앞 (front) 에서 맨 끝 (rear) 방향으로 선형 검색을 수행. 따라서 스캔 시 주목할 인덱스 idx 를 구하는 식은 `(i+front) % capacity` 가 된다. 
> 검색에 성공하면 찾은 원소의 인덱스 값을 반환하며, 실패시 -1 을 반환한다.

__08. 데이터 개수를 세는 `count()` 함수__
> 큐에 있는 데이터 (value) 개수를 구하여 반환.

__09. 데이터가 포함되어 있는지를 판단하는 `__contains__()` 함수__
> 큐에 데이터 (value)	가 들어있는지를 판단하는 함수. 들어있다면 True, 아니라면 False 를 반환. 내부의 `count()` 함수를 호출하여 구현.

__10. 큐의 전체 원소를 삭제하는 `clear()` 함수__
> 큐에 들어있는 모든 데이터를 삭제하는 함수. no / front / rear 의 값을 0으로 바꿔주면 된다.

__11. 큐의 전체 데이터를 출력하는 `dump()` 함수__
> 큐에 들어있는 모든 데이터를 맨 앞부터 끝 방향으로 순서대로 출력. 큐가 비어있다면 "큐가 비어 있습니다." 를 출력.

* 양방향 대기열 덱의 구조
	- 양방향 대기열인 덱 (deque) 은 맨 앞과 맨 끝, 양쪽에서 데이터를 넣고 꺼낼 수 있는 자료구조.

# 링 버퍼 (ring buffer)

[링 버퍼 코드 구현](https://github.com/ParkJongham/ham/blob/master/Coding/code/%EB%A7%81%EB%B2%84%ED%8D%BC(%ED%81%90).ipynb)

> 디큐 시 배열 안의 원소를 옮기지 않는 자료구조. 배열 맨 끝의 원소 뒤에 맨 앞의 원소가 연결되는 자료구조로. 피자 처럼 원형으로 볼 수 있다.

프런트 (front) : 맨 앞에 있는 원소.
리어 (rear) : 맨 뒤에 있는 원소 바로 뒤의 인덱스 (다음 인큐되는 데이터의 저장 위치)
* 인큐와 디큐를 수행하면 프런트와 리어 값은 변한다. 링버퍼를 활용하면 인큐와 디큐 시 원소를 옮겨 줄 필요없어 시간 복잡도는 항상 O(1) 이다.

* 오래된 데이터를 버리는 용도로 활용이 가능.
	* 예) 원소 수가 n 인 배열에 데이터를 계속해서 입력할 떄 가장 최근에 들어온 데이터 n개만 저장하고 나머지 오래된 데이터는 버리는 경우 활용.
